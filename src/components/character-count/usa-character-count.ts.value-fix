import { css, html } from 'lit';
import { customElement, property, state } from 'lit/decorators.js';
import { USWDSBaseComponent } from '../../utils/base-component.js';

// Import official USWDS compiled CSS
import '../../styles/styles.css';

/**
 * ARCHITECTURE: Option B (Pure Global Init)
 * - USWDS is initialized globally via .on(document) in .storybook/preview-head.html
 * - This component ONLY renders HTML structure
 * - All behavior managed by USWDS event delegation
 * - Component properties synced to USWDS-created elements
 *
 * USA Character Count Web Component
 *
 * Minimal wrapper around USWDS character count functionality.
 * All character counting logic, visual state updates, and accessibility features are managed by USWDS JavaScript.
 *
 * @element usa-character-count
 * @fires character-count-change - Dispatched when character count changes (via USWDS)
 *
 * @see README.mdx - Complete API documentation, usage examples, and implementation notes
 * @see CHANGELOG.mdx - Component version history and breaking changes
 * @see TESTING.mdx - Testing documentation and coverage reports
 *
 * @uswds-js-reference https://github.com/uswds/uswds/tree/develop/packages/usa-character-count/src/index.js
 * @uswds-css-reference https://github.com/uswds/uswds/tree/develop/packages/usa-character-count/src/styles/_usa-character-count.scss
 * @uswds-docs https://designsystem.digital.gov/components/character-count/
 * @uswds-guidance https://designsystem.digital.gov/components/character-count/#guidance
 * @uswds-accessibility https://designsystem.digital.gov/components/character-count/#accessibility
 */
@customElement('usa-character-count')
export class USACharacterCount extends USWDSBaseComponent {
  static override styles = css`
    :host {
      display: block;
    }
    :host([hidden]) {
      display: none;
    }
  `;

  @property({ type: String })
  value = '';

  @property({ type: Number })
  maxlength = 0;

  @property({ type: String })
  label = 'Text input with character count';

  @property({ type: String })
  hint = '';

  @property({ type: String })
  name = 'character-count';

  @property({ type: String })
  inputType: 'input' | 'textarea' = 'textarea';

  @property({ type: Number })
  rows = 5;

  @property({ type: String })
  placeholder = '';

  @property({ type: Boolean })
  disabled = false;

  @property({ type: Boolean })
  required = false;

  @property({ type: Boolean })
  readonly = false;

  @property({ type: String })
  error = '';

  @state()
  private _currentLength = 0;

  @state()
  private _isNearLimit = false;

  @state()
  private _isOverLimit = false;

  // Store USWDS module for cleanup
  private uswdsModule: any = null;
  private uswdsInitialized = false;

  // Light DOM is handled by USWDSBaseComponent

  override connectedCallback() {
    super.connectedCallback();

    // Set web component managed flag to prevent USWDS auto-initialization conflicts
    this.setAttribute('data-web-component-managed', 'true');

    this.updateCharacterCount();  }

  override disconnectedCallback() {
    super.disconnectedCallback();
    this.cleanupUSWDS();
  }

  


  private syncStateToUSWDS() {
    // Sync component properties to USWDS-managed elements after they've been enhanced
    setTimeout(() => {
      const field = this.querySelector('textarea') || this.querySelector('input');

      if (field) {
        // Sync maxlength attribute
        if (this.maxlength > 0) {
          field.setAttribute('maxlength', this.maxlength.toString());
        } else {
          field.removeAttribute('maxlength');
        }

        // Sync disabled state
        field.disabled = this.disabled;

        // Sync required state
        field.required = this.required;

        // Sync aria-describedby to include hint and error references
        const ariaDescribedby = `${this.name}-info${this.hint ? ` ${this.name}-hint` : ''}${this.error ? ` ${this.name}-error` : ''}`;
        field.setAttribute('aria-describedby', ariaDescribedby);

        // Sync value if different
        if (this.value !== field.value) {
          field.value = this.value;
          // Trigger USWDS to update character count display
          field.dispatchEvent(new Event('input', { bubbles: true }));
        }
      }
    }, 0);
  }

  private async cleanupUSWDS() {
    try {
      const { cleanupUSWDSComponent } = await import('../../utils/uswds-loader.js');
      cleanupUSWDSComponent(this, this.uswdsModule);
    } catch (error) {
      console.warn('⚠️ Character Count: Error importing cleanup utility:', error);
    }

    this.uswdsModule = null;
    this.uswdsInitialized = false;
  }

  override shouldUpdate(changedProperties: Map<string, any>): boolean {
    // Always allow re-renders for character count message updates
    const hasCharacterCountUpdate = changedProperties.has('value') ||
                                   changedProperties.has('maxlength') ||
                                   this._currentLength !== this.value.length;

    if (hasCharacterCountUpdate) {
      return true;
    }

    // If USWDS has taken control of the DOM, be selective about what changes trigger re-renders
    if (this.uswdsInitialized) {
      // Allow critical updates that need DOM changes or USWDS sync
      const allowedUpdates = ['disabled', 'required', 'maxlength', 'error', 'value', 'inputType', 'rows', 'placeholder', 'readonly', 'hint', 'label'];
      const hasAllowedUpdate = Array.from(changedProperties.keys()).some(prop =>
        allowedUpdates.includes(prop)
      );

      if (!hasAllowedUpdate) {
        return false;
      }
    }

    return super.shouldUpdate(changedProperties);
  }

  override update(changedProperties: Map<PropertyKey, unknown>) {
    try {
      super.update(changedProperties);
    } catch (error) {
      // Handle case where USWDS has manipulated DOM and Lit's marker nodes are gone
      // This can happen when USWDS transforms the component after initialization
      if (error instanceof Error && error.message.includes('ChildPart')) {
        console.warn('Character count: USWDS has transformed DOM, skipping Lit update', error);
        return;
      }
      throw error;
    }
  }

  override updated(changedProperties: Map<string, any>) {
    super.updated(changedProperties);

    if (this.uswdsInitialized) {
      // If USWDS is active and critical properties changed, sync them to USWDS-managed elements
      if (changedProperties.has('maxlength') || changedProperties.has('value') || changedProperties.has('hint') || changedProperties.has('error')) {
        this.syncStateToUSWDS();
      }
    }

    // Always ensure our internal state is up to date
    if (changedProperties.has('value') || changedProperties.has('maxlength')) {
      this.updateCharacterCountSync();
    }
  }

  override willUpdate(changedProperties: Map<string, any>) {
    super.willUpdate(changedProperties);
    // Always update character count when value or maxlength changes
    if (changedProperties.has('value') || changedProperties.has('maxlength')) {
      this.updateCharacterCountSync();
    }
  }

  private updateCharacterCount() {
    // Public method for external use - can trigger updates
    this.updateCharacterCountSync();
  }

  private updateCharacterCountSync() {
    const newLength = this.value.length;

    let newIsNearLimit = false;
    let newIsOverLimit = false;

    if (this.maxlength > 0) {
      const remaining = this.maxlength - newLength;
      newIsNearLimit = remaining <= Math.floor(this.maxlength * 0.1) && remaining > 0;
      newIsOverLimit = remaining < 0;
    }

    // Update state properties - these will trigger re-render if changed
    const oldLength = this._currentLength;
    const oldNearLimit = this._isNearLimit;
    const oldOverLimit = this._isOverLimit;

    this._currentLength = newLength;
    this._isNearLimit = newIsNearLimit;
    this._isOverLimit = newIsOverLimit;

    // Dispatch event if something changed
    const hasChanges =
      oldLength !== newLength || oldNearLimit !== newIsNearLimit || oldOverLimit !== newIsOverLimit;

    if (hasChanges) {
      this.requestUpdate(); // Ensure re-render happens
      this.dispatchEvent(
        new CustomEvent('character-count-change', {
          detail: {
            currentLength: this._currentLength,
            maxLength: this.maxlength,
            remaining: this.maxlength > 0 ? this.maxlength - this._currentLength : null,
            isNearLimit: this._isNearLimit,
            isOverLimit: this._isOverLimit,
            value: this.value,
          },
          bubbles: true,
          composed: true,
        })
      );
    }
  }

  private handleInput(e: Event) {
    const target = e.target as HTMLInputElement | HTMLTextAreaElement;
    this.value = target.value;

    // Only update character count if USWDS is not handling it
    if (!this.uswdsInitialized) {
      this.updateCharacterCount();
    }
  }

  private getCharacterCountMessage(): string {
    if (this.maxlength <= 0) {
      return `${this._currentLength} characters`;
    }

    const remaining = this.maxlength - this._currentLength;

    if (remaining < 0) {
      return `${Math.abs(remaining)} characters over limit`;
    } else if (remaining === 0) {
      return 'Character limit reached';
    } else if (remaining === 1) {
      return `${remaining} character remaining`;
    } else {
      return `${remaining} characters remaining`;
    }
  }

  private getCharacterCountClasses(): string {
    const classes = ['usa-character-count__status', 'usa-character-count__message'];

    // USWDS uses different class names for states
    if (this._isOverLimit) {
      classes.push('usa-character-count__status--invalid');
    }

    return classes.join(' ');
  }

  // Public API methods
  override focus() {
    const input = this.querySelector(`#${this.name}`) as HTMLInputElement | HTMLTextAreaElement;
    if (input) {
      input.focus();
    }
  }

  override blur() {
    const input = this.querySelector(`#${this.name}`) as HTMLInputElement | HTMLTextAreaElement;
    if (input) {
      input.blur();
    }
  }

  select() {
    const input = this.querySelector(`#${this.name}`) as HTMLInputElement | HTMLTextAreaElement;
    if (input) {
      input.select();
    }
  }

  clear() {
    this.value = '';
    this.updateCharacterCount();
  }

  getCharacterCount(): number {
    return this._currentLength;
  }

  getRemainingCharacters(): number | null {
    return this.maxlength > 0 ? this.maxlength - this._currentLength : null;
  }

  isNearLimit(): boolean {
    return this._isNearLimit;
  }

  isOverLimit(): boolean {
    return this._isOverLimit;
  }

  private renderRequiredIndicator() {
    if (!this.required) return '';

    return html`<span class="usa-hint--required">*</span>`;
  }

  private renderHint() {
    if (!this.hint) return '';

    return html`<div class="usa-hint" id="${this.name}-hint">${this.hint}</div>`;
  }

  private renderTextarea() {
    const ariaDescribedby = `${this.name}-info${this.hint ? ` ${this.name}-hint` : ''}${this.error ? ` ${this.name}-error` : ''}`;

    return html`
      <textarea
        class="usa-textarea usa-character-count__field"
        id="${this.name}"
        name="${this.name}"
        placeholder="${this.placeholder}"
        ?disabled=${this.disabled}
        ?required=${this.required}
        ?readonly=${this.readonly}
        maxlength="${this.maxlength > 0 ? this.maxlength : ''}"
        rows="${this.rows}"
        .value="${this.value}"
        @input=${this.handleInput}
        aria-describedby="${ariaDescribedby}"
      ></textarea>
    `;
  }

  private renderInput() {
    const ariaDescribedby = `${this.name}-info${this.hint ? ` ${this.name}-hint` : ''}${this.error ? ` ${this.name}-error` : ''}`;

    return html`
      <input
        class="usa-input usa-character-count__field"
        type="text"
        id="${this.name}"
        name="${this.name}"
        placeholder="${this.placeholder}"
        ?disabled=${this.disabled}
        ?required=${this.required}
        ?readonly=${this.readonly}
        maxlength="${this.maxlength > 0 ? this.maxlength : ''}"
        .value="${this.value}"
        @input=${this.handleInput}
        aria-describedby="${ariaDescribedby}"
      />
    `;
  }

  private renderField() {
    return this.inputType === 'textarea' ? this.renderTextarea() : this.renderInput();
  }


  // Use light DOM for USWDS compatibility
  protected override createRenderRoot(): HTMLElement {
    return this as any;
  }

    override render() {
    const hasError = this.error || this._isOverLimit;
    const containerClasses = `usa-character-count usa-form-group${hasError ? ' usa-form-group--error' : ''}`;

    // Render the initial structure that USWDS expects
    return html`
      <div
        class="${containerClasses}"
        data-maxlength="${this.maxlength}"
      >
        <label class="usa-label" for="${this.name}">
          ${this.label} ${this.renderRequiredIndicator()}
        </label>
        ${this.renderHint()}
        ${this.error ? html`<div class="usa-error-message" id="${this.name}-error">${this.error}</div>` : ''}
        ${this.renderField()}
        <!-- USWDS expects this element to exist for enhancement -->
        <div
          class="${this.getCharacterCountClasses()}"
          id="${this.name}-info"
          aria-live="polite"
        >
          ${this.getCharacterCountMessage()}
        </div>
      </div>
    `;
  }
}
