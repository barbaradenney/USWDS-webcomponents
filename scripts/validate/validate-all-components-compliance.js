#!/usr/bin/env node

/**
 * Comprehensive USWDS Compliance Validator for All Components
 *
 * Validates all components against our light wrapper approach:
 * 1. HTML structure alignment with official USWDS
 * 2. JavaScript integration patterns
 * 3. CSS compliance (minimal custom styles)
 * 4. Required attributes and accessibility
 */

import { readFileSync, readdirSync, existsSync } from 'fs';
import { join, dirname, basename } from 'path';
import { fileURLToPath } from 'url';
import { getAllComponentPaths, getAllComponentNames } from '../utils/find-components.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Color helpers for console output
const colors = {
  bold: text => `\x1b[1m${text}\x1b[0m`,
  red: text => `\x1b[31m${text}\x1b[0m`,
  green: text => `\x1b[32m${text}\x1b[0m`,
  yellow: text => `\x1b[33m${text}\x1b[0m`,
  blue: text => `\x1b[34m${text}\x1b[0m`,
  magenta: text => `\x1b[35m${text}\x1b[0m`,
  cyan: text => `\x1b[36m${text}\x1b[0m`,
  gray: text => `\x1b[90m${text}\x1b[0m`
};

// USWDS HTML structure patterns for ALL components
const USWDS_HTML_PATTERNS = {
  modal: {
    structure: [
      'usa-modal__content',
      'usa-modal__main',
      'usa-modal__heading',
      'usa-modal__footer',
      'usa-modal__close'
    ],
    elementOrder: [
      // Close button should come AFTER main (improved pattern matching)
      { search: 'class="usa-modal__main"', shouldComeBefore: 'class="usa-modal__close"' },
      // Footer should be INSIDE main
      { search: 'usa-modal__main', shouldContain: 'usa-modal__footer' }
    ],
    requiredAttributes: [
      'aria-labelledby',
      'aria-describedby',
      'role="dialog"',
      'aria-modal="true"',
      'data-close-modal'
    ],
    buttonStructure: [
      'usa-button-group',
      'usa-button-group__item'
    ],
    // Note: Modal MUST use inline HTML (buttons and SVG) for USWDS compatibility
    // Cannot use <usa-icon> or <usa-button> web components - USWDS JavaScript expects specific HTML structure
  },
  accordion: {
    structure: [
      'usa-accordion',
      'usa-accordion__heading',
      'usa-accordion__button',
      'usa-accordion__content'
    ],
    requiredAttributes: [
      'aria-expanded',
      'aria-controls'
      // Note: 'hidden' attribute is set dynamically by USWDS behavior, not aria-hidden
    ]
  },
  'combo-box': {
    structure: ['usa-combo-box', 'select'], // Minimal structure - USWDS generates interactive elements
    requiredAttributes: ['aria-describedby'] // Select attributes, not transformed combobox attributes
  },
  'date-picker': {
    structure: [
      'usa-date-picker'
    ],
    optionalStructure: [
      'usa-date-picker__wrapper',  // Generated dynamically by USWDS
      'usa-date-picker__button',   // Generated dynamically by USWDS
      'usa-date-picker__external-input'
    ]
  },
  // Add patterns for all other components
  alert: {
    structure: ['usa-alert', 'usa-alert__body', 'usa-alert__heading'],
    requiredAttributes: ['role']
  },
  banner: {
    structure: ['usa-banner', 'usa-banner__content'],
    requiredAttributes: ['aria-label']
  },
  breadcrumb: {
    structure: ['usa-breadcrumb', 'usa-breadcrumb__list', 'usa-breadcrumb__list-item', 'usa-breadcrumb__link'],
    requiredAttributes: ['aria-label']
  },
  button: {
    structure: ['usa-button'],
    requiredAttributes: ['type']
  },
  'button-group': {
    structure: ['usa-button-group', 'usa-button-group__item']
  },
  card: {
    structure: ['usa-card', 'usa-card__container', 'usa-card__header', 'usa-card__body', 'usa-card__media', 'usa-card__footer', 'usa-card__heading']
  },
  'character-count': {
    structure: ['usa-character-count', 'usa-character-count__field', 'usa-character-count__message'],
    requiredAttributes: ['aria-describedby']
  },
  checkbox: {
    structure: ['usa-checkbox', 'usa-checkbox__input', 'usa-checkbox__label'],
    requiredAttributes: ['type="checkbox"']
  },
  collection: {
    structure: ['usa-collection', 'usa-collection__item']
  },
  'date-range-picker': {
    structure: ['usa-date-range-picker', 'usa-date-picker'],
    requiredAttributes: ['aria-label']
  },
  'file-input': {
    structure: ['usa-file-input'],  // Minimal structure - USWDS generates the rest
    requiredAttributes: ['type="file"'],
    optionalStructure: ['usa-file-input__target', 'usa-file-input__instructions']  // Generated by USWDS
  },
  footer: {
    structure: ['usa-footer', 'usa-footer__nav', 'usa-footer__primary-section'],
    optionalStructure: ['usa-footer__secondary-section', 'usa-footer__return-to-top'],
    requiredAttributes: ['role="contentinfo"'],
    forbiddenClasses: ['usa-identifier'],  // Identifier should be separate component
    architecturalNote: 'Footer and identifier are separate components - identifier should not be rendered inside footer'
  },
  header: {
    structure: ['usa-header', 'usa-navbar', 'usa-nav'],
    requiredAttributes: ['role="banner"'],
    shouldUseComponents: ['usa-search'],  // Header should use usa-search component for search functionality
    compositionNote: 'Use usa-search web component instead of inline search HTML markup'
  },
  icon: {
    structure: ['usa-icon'],
    requiredAttributes: ['aria-hidden', 'role="img"', 'focusable="false"']
  },
  identifier: {
    structure: ['usa-identifier', 'usa-identifier__section']
  },
  'in-page-navigation': {
    structure: ['usa-in-page-nav', 'usa-in-page-nav__list', 'usa-in-page-nav__item'],
    requiredAttributes: ['aria-label']
  },
  'input-prefix-suffix': {
    structure: ['usa-input-group', 'usa-input-prefix', 'usa-input-suffix']
  },
  'language-selector': {
    structure: ['usa-language-selector', 'usa-language-selector__button'],
    requiredAttributes: ['aria-expanded', 'aria-haspopup']
  },
  link: {
    structure: ['usa-link'],
    requiredAttributes: ['href']
  },
  list: {
    structure: ['usa-list']
  },
  'memorable-date': {
    structure: ['usa-memorable-date', 'usa-form-group'],
    requiredAttributes: ['aria-describedby']
  },
  // menu: Removed - component not implemented yet
  pagination: {
    structure: ['usa-pagination', 'usa-pagination__list', 'usa-pagination__item'],
    requiredAttributes: ['aria-label', 'role="navigation"']
  },
  'process-list': {
    structure: ['usa-process-list', 'usa-process-list__item']
  },
  prose: {
    structure: ['usa-prose']
  },
  radio: {
    structure: ['usa-radio', 'usa-radio__input', 'usa-radio__label'],
    requiredAttributes: ['type="radio"', 'name']
  },
  'range-slider': {
    structure: ['usa-range', 'usa-range__input'],
    requiredAttributes: ['type="range"', 'aria-describedby']
  },
  search: {
    structure: ['usa-search', 'usa-search__input', 'usa-search__submit'],
    requiredAttributes: ['role="search"', 'aria-label']
  },
  // section: Removed - component not implemented yet
  select: {
    structure: ['usa-form-group', 'usa-label', 'usa-select'],
    requiredAttributes: ['for', 'id', 'name']
  },
  'side-navigation': {
    structure: ['usa-sidenav', 'usa-sidenav__list', 'usa-sidenav__item'],
    requiredAttributes: ['aria-label']
  },
  'site-alert': {
    structure: ['usa-site-alert', 'usa-alert', 'usa-alert__body'],
    requiredAttributes: ['role']
  },
  'skip-link': {
    structure: ['usa-skip-link'],
    requiredAttributes: ['href']
  },
  'step-indicator': {
    structure: ['usa-step-indicator', 'usa-step-indicator__segments', 'usa-step-indicator__segment'],
    requiredAttributes: ['aria-label']
  },
  'summary-box': {
    structure: ['usa-summary-box', 'usa-summary-box__body']
  },
  table: {
    structure: ['usa-table', 'thead', 'tbody'],
    requiredAttributes: ['role="table"']
  },
  tag: {
    structure: ['usa-tag']
  },
  'text-input': {
    structure: ['usa-form-group', 'usa-label', 'usa-input'],
    requiredAttributes: ['for', 'id', 'name', 'type']
  },
  textarea: {
    structure: ['usa-textarea'],
    requiredAttributes: ['aria-describedby']
  },
  'time-picker': {
    structure: ['usa-time-picker', 'usa-input'], // Minimal structure - USWDS generates combo-box
    requiredAttributes: ['aria-describedby']
  },
  tooltip: {
    structure: ['usa-tooltip', 'usa-tooltip__body'],
    requiredAttributes: ['data-position', 'aria-describedby']
  },
  validation: {
    structure: ['usa-error-message', 'usa-sr-only'],
    requiredAttributes: ['role="alert"']
  }
};

// Components that require USWDS JavaScript integration (interactive)
const INTERACTIVE_COMPONENTS = [
  'accordion', 'modal', 'date-picker', 'date-range-picker', 'combo-box',
  'file-input', 'character-count', 'language-selector', 'tooltip',
  'time-picker', 'in-page-navigation', 'header', 'footer'
];

// Components where USWDS transforms/generates the DOM structure
// These should provide minimal initial structure and let USWDS create the rest
const USWDS_DOM_TRANSFORMATION_COMPONENTS = {
  'time-picker': {
    description: 'USWDS transforms input into select + combo-box',
    initialStructure: '<div class="usa-time-picker"><input class="usa-input" /></div>',
    generatedElements: ['select', '.usa-combo-box__input', '.usa-combo-box__toggle-list'],
    forbiddenPreBuilt: ['.usa-combo-box', '.usa-combo-box__toggle-list', 'select'],
    warningMessage: 'Time picker should NOT pre-build combo-box structure - USWDS generates it'
  },
  'file-input': {
    description: 'USWDS creates drag-drop structure around input',
    initialStructure: '<input class="usa-file-input" type="file" />',
    generatedElements: ['.usa-file-input__target', '.usa-file-input__box', '.usa-file-input__instructions'],
    forbiddenPreBuilt: ['.usa-file-input__target', '.usa-file-input__box'],
    warningMessage: 'File input should be a simple input - USWDS generates drag-drop structure'
  },
  'modal': {
    description: 'USWDS can generate modal structure dynamically',
    initialStructure: 'Can be generated via USWDS.modal.create() or provided',
    generatedElements: ['.usa-modal-wrapper', '.usa-modal-overlay'],
    forbiddenPreBuilt: [],  // Modal can have pre-built structure
    warningMessage: 'Modal structure can be pre-built or generated'
  },
  'date-picker': {
    description: 'USWDS transforms input into date picker with calendar',
    initialStructure: '<div class="usa-date-picker"><input class="usa-input" /></div>',
    generatedElements: ['.usa-date-picker__button', '.usa-date-picker__calendar'],
    forbiddenPreBuilt: ['.usa-date-picker__calendar'],
    warningMessage: 'Date picker should NOT pre-build calendar - USWDS generates it'
  },
  'combo-box': {
    description: 'USWDS transforms select into searchable combo-box',
    initialStructure: '<div class="usa-combo-box"><select><option>...</option></select></div>',
    generatedElements: ['.usa-combo-box__input', '.usa-combo-box__list', '.usa-combo-box__toggle-list'],
    forbiddenPreBuilt: ['.usa-combo-box__input', '.usa-combo-box__list', '.usa-combo-box__toggle-list'],
    warningMessage: 'Combo-box should start with select element - USWDS generates the input and interactive elements'
  }
};

// Light wrapper approach requirements
const LIGHT_WRAPPER_REQUIREMENTS = {
  // Must have USWDS JS integration for interactive components
  jsIntegration: [
    /USWDS\.\w+\.on\(/,
    /import.*@uswds\/uswds\/js/,
    /modalModule\.on\(/,
    /accordionModule\.on\(/,
    /await import\([\s\S]*?@uswds\/uswds\/js/,
    /initializeUSWDSComponent\(/,
    /module\.init\(this\)/,  // Support for modal and date-picker init() pattern
    /initialize\w+\(this\)/,  // Support for USWDS-Mirrored Behavior pattern (e.g., initializeModal, initializeAccordion)
    /from ['"]\.\/usa-[\w-]+-behavior\.(?:js|ts)['"]/  // Import from behavior file indicates mirrored behavior pattern (supports hyphens in component names)
  ],

  // Must use light DOM
  lightDOM: [
    /createRenderRoot[\s\S]*?return this/,
    /extends USWDSBaseComponent/
  ],

  // Must import USWDS styles
  stylesImport: [
    /import.*styles\.css/,
    /import.*'.*styles\.css'/
  ],

  // Should have web component management
  webComponentManaged: [
    /data-web-component-managed/
  ]
};

// CSS compliance - what's allowed vs forbidden
const CSS_RULES = {
  allowed: [
    // Host display styles only
    /:host\s*\{[^}]*display:/,
    /:host\([^)]*\)\s*\{[^}]*display:/,
    /:host\([^)]*\)\s*\{[^}]*visibility:/,
    // USWDS imports
    /import.*styles\.css/
  ],

  forbidden: [
    // Custom styling beyond host
    /\.[a-z-]+\s*\{[^}]*(?:color|background|font|margin|padding|border):/,
    /@media/,
    /custom-/,
    /\.my-/,
    /\.component-/
  ]
};

/**
 * Validate HTML structure compliance
 */
function validateHTMLStructure(content, componentName) {
  const issues = [];
  const successes = [];
  const patterns = USWDS_HTML_PATTERNS[componentName];

  if (!patterns) {
    return { issues, successes, warnings: [`No HTML validation patterns defined for ${componentName}`] };
  }

  // Check if component uses USWDS-Mirrored Behavior pattern
  const componentPaths = getAllComponentPaths();
  const componentDir = componentPaths.find(p => basename(p) === componentName);
  const hasBehaviorFile = componentDir && (
    existsSync(join(componentDir, `usa-${componentName}-behavior.ts`)) ||
    existsSync(join(componentDir, `usa-${componentName}-behavior.js`))
  );
  let behaviorContent = '';

  if (hasBehaviorFile && componentDir) {
    try {
      const behaviorPath = join(componentDir, `usa-${componentName}-behavior.ts`);
      if (existsSync(behaviorPath)) {
        behaviorContent = readFileSync(behaviorPath, 'utf8');
      }
    } catch (e) {
      // Behavior file might not exist or be readable
    }
  }

  // Check required structure classes
  patterns.structure.forEach(className => {
    if (content.includes(className)) {
      successes.push(`âœ“ Has ${className}`);
    } else {
      issues.push(`Missing required USWDS class: ${className}`);
    }
  });

  // Check optional structure classes (don't fail validation if missing)
  if (patterns.optionalStructure) {
    patterns.optionalStructure.forEach(className => {
      if (content.includes(className)) {
        successes.push(`âœ“ Has optional ${className}`);
      } else {
        // Optional - just note but don't add to issues
        successes.push(`â—‹ Optional ${className} not present (acceptable)`);
      }
    });
  }

  // Check element ordering
  if (patterns.elementOrder) {
    patterns.elementOrder.forEach(order => {
      if (order.shouldComeBefore) {
        const firstIndex = content.indexOf(order.search);
        const secondIndex = content.indexOf(order.shouldComeBefore);

        if (firstIndex > -1 && secondIndex > -1) {
          if (firstIndex < secondIndex) {
            successes.push(`âœ“ Correct order: ${order.search} before ${order.shouldComeBefore}`);
          } else {
            issues.push(`Incorrect order: ${order.search} should come before ${order.shouldComeBefore}`);
          }
        }
      }

      if (order.shouldContain) {
        const parentMatch = content.match(new RegExp(`${order.search}[\\s\\S]*?${order.shouldContain}`, 'g'));
        if (parentMatch) {
          successes.push(`âœ“ ${order.search} contains ${order.shouldContain}`);
        } else {
          issues.push(`${order.search} should contain ${order.shouldContain}`);
        }
      }
    });
  }

  // Check required attributes
  if (patterns.requiredAttributes) {
    patterns.requiredAttributes.forEach(attr => {
      // Check component template first
      if (content.includes(attr)) {
        successes.push(`âœ“ Has ${attr}`);
      } else if (behaviorContent) {
        // For USWDS-Mirrored Behavior components, check behavior file
        // Convert attribute format: role="dialog" -> .setAttribute('role', 'dialog')
        const attrMatch = attr.match(/(\w+(?:-\w+)*)="([^"]+)"/);
        if (attrMatch) {
          const [, attrName, attrValue] = attrMatch;
          const setAttributePattern = `setAttribute('${attrName}', '${attrValue}')`;
          const setAttributePatternDouble = `setAttribute("${attrName}", "${attrValue}")`;
          if (behaviorContent.includes(setAttributePattern) || behaviorContent.includes(setAttributePatternDouble)) {
            successes.push(`âœ“ Has ${attr} (added dynamically by USWDS behavior)`);
            return;
          }
        }
        // Also check for direct string match
        if (behaviorContent.includes(attr)) {
          successes.push(`âœ“ Has ${attr} (added dynamically by USWDS behavior)`);
          return;
        }
        issues.push(`Missing required attribute: ${attr}`);
      } else {
        issues.push(`Missing required attribute: ${attr}`);
      }
    });
  }

  // Check for forbidden classes (architectural boundaries)
  if (patterns.forbiddenClasses) {
    // Extract render method to check actual implementation, not comments
    const renderMatch = content.match(/override\s+render\s*\(\s*\)\s*\{[\s\S]*?\n\s*\}/);
    const renderContent = renderMatch ? renderMatch[0] : content;

    patterns.forbiddenClasses.forEach(forbiddenClass => {
      // Check in render method (or full content if render not found)
      // Look for class usage patterns like class="usa-identifier" or usa-identifier component
      const classUsagePattern = new RegExp(`(class=["'].*?${forbiddenClass}.*?["']|<${forbiddenClass}[\\s>]|\\.${forbiddenClass})`);

      if (classUsagePattern.test(renderContent)) {
        issues.push(`Forbidden class found: ${forbiddenClass}`);
        if (patterns.architecturalNote) {
          issues.push(`  â†’ ${patterns.architecturalNote}`);
        }
      } else {
        successes.push(`âœ“ Does not contain forbidden class: ${forbiddenClass}`);
      }
    });
  }

  // Check for component composition (should use web components instead of inline HTML)
  if (patterns.shouldUseComponents) {
    // Extract render method to check actual implementation
    const renderMatch = content.match(/override\s+render\s*\(\s*\)\s*\{[\s\S]*?\n\s*\}/);
    const renderContent = renderMatch ? renderMatch[0] : content;

    patterns.shouldUseComponents.forEach(requiredComponent => {
      // Check if component is actually used
      const componentUsagePattern = new RegExp(`<${requiredComponent}[\\s>]`);

      if (componentUsagePattern.test(renderContent)) {
        successes.push(`âœ“ Uses ${requiredComponent} web component`);
      } else {
        // Check if inline HTML for this component exists
        const componentClass = requiredComponent.replace('usa-', 'usa-');
        const inlinePattern = new RegExp(`class=["'][^"']*${componentClass}[^"']*["']`);

        if (inlinePattern.test(renderContent)) {
          issues.push(`Should use <${requiredComponent}> web component instead of inline HTML`);
          if (patterns.compositionNote) {
            issues.push(`  â†’ ${patterns.compositionNote}`);
          }
        } else {
          // Component functionality not present - that's okay, it's optional
          successes.push(`âœ“ Component composition check passed (${requiredComponent} not needed or properly used)`);
        }
      }
    });
  }

  // Check button structure for components that need it
  if (patterns.buttonStructure) {
    patterns.buttonStructure.forEach(className => {
      if (content.includes(className)) {
        successes.push(`âœ“ Has button structure: ${className}`);
      } else {
        issues.push(`Missing button structure: ${className}`);
      }
    });
  }

  return { issues, successes, warnings: [] };
}

/**
 * Validate JavaScript integration
 */
function validateJSIntegration(content, componentName) {
  const issues = [];
  const successes = [];
  const warnings = [];

  const isInteractive = INTERACTIVE_COMPONENTS.includes(componentName);

  if (isInteractive) {
    // Check for USWDS JS integration
    const hasJSIntegration = LIGHT_WRAPPER_REQUIREMENTS.jsIntegration.some(pattern =>
      pattern.test(content)
    );

    // Check if component has behavior file (USWDS-Mirrored Behavior pattern)
    const componentPaths = getAllComponentPaths();
    const componentDir = componentPaths.find(p => basename(p) === componentName);
    const hasBehaviorFile = componentDir && (
      existsSync(join(componentDir, `usa-${componentName}-behavior.ts`)) ||
      existsSync(join(componentDir, `usa-${componentName}-behavior.js`))
    );

    // Check for @uswds-behavior-disabled annotation (intentionally disabled for Lit compatibility)
    const hasBehaviorDisabled = content.includes('@uswds-behavior-disabled');

    if (hasJSIntegration) {
      successes.push('âœ“ Has USWDS JavaScript integration');
    } else if (hasBehaviorFile && hasBehaviorDisabled) {
      successes.push('âœ“ Has USWDS-Mirrored Behavior (behavior disabled for Lit DOM compatibility)');
    } else if (hasBehaviorFile) {
      successes.push('âœ“ Has USWDS-Mirrored Behavior pattern (behavior file exists)');
    } else {
      issues.push('Missing USWDS JavaScript integration for interactive component');
    }
  }

  // Check for light DOM usage
  const hasLightDOM = LIGHT_WRAPPER_REQUIREMENTS.lightDOM.some(pattern =>
    pattern.test(content)
  );

  if (hasLightDOM) {
    successes.push('âœ“ Uses light DOM');
  } else {
    warnings.push('Consider using light DOM for USWDS compatibility');
  }

  // Check for USWDS styles import
  const hasStylesImport = LIGHT_WRAPPER_REQUIREMENTS.stylesImport.some(pattern =>
    pattern.test(content)
  );

  if (hasStylesImport) {
    successes.push('âœ“ Imports USWDS styles');
  } else {
    issues.push('Missing USWDS styles import');
  }

  // Check for web component management
  const hasWebComponentManaged = LIGHT_WRAPPER_REQUIREMENTS.webComponentManaged.some(pattern =>
    pattern.test(content)
  );

  if (hasWebComponentManaged) {
    successes.push('âœ“ Has data-web-component-managed');
  } else {
    warnings.push('Consider adding data-web-component-managed attribute');
  }

  return { issues, successes, warnings };
}

/**
 * Validate CSS compliance
 */
function validateCSS(content) {
  const issues = [];
  const successes = [];
  const warnings = [];

  // Extract CSS from component
  const styleMatch = content.match(/static\s+(?:override\s+)?styles\s*=\s*css`([^`]*)`/);

  if (!styleMatch) {
    successes.push('âœ“ No custom styles (uses USWDS only)');
    return { issues, successes, warnings };
  }

  const styles = styleMatch[1];

  // Check for forbidden patterns
  CSS_RULES.forbidden.forEach(pattern => {
    if (pattern.test(styles)) {
      issues.push(`Forbidden CSS pattern: ${pattern.source.substring(0, 30)}...`);
    }
  });

  // Check if styles are minimal (only :host)
  const lines = styles.split('\n').filter(line => line.trim());
  const nonHostLines = lines.filter(line =>
    !line.includes(':host') &&
    line.trim() !== '}' &&
    line.trim() !== '{' &&
    !line.includes('import')
  );

  if (nonHostLines.length === 0) {
    successes.push('âœ“ CSS compliant (only :host styles)');
  } else if (nonHostLines.length <= 3) {
    successes.push('âœ“ CSS compliant (minimal :host styles only)');
  } else {
    issues.push('Has extensive custom CSS (should use USWDS classes)');
  }

  return { issues, successes, warnings };
}

/**
 * Validate CSS selector patterns that components use
 * Prevents "gray button" issues by ensuring attributes match USWDS CSS selectors
 */
function validateCSSSelectors(content, componentName) {
  const issues = [];
  const successes = [];
  const warnings = [];

  // USWDS CSS selector patterns that components must match
  const criticalPatterns = {
    table: {
      // Table sort buttons require aria-sort="none" or no aria-sort attribute
      ariaSortPattern: {
        goodPatterns: [
          'aria-sort="none"',
          'aria-sort="ascending"',
          'aria-sort="descending"',
          'aria-sort="${ariaSort || \'none\'}"',
          'aria-sort="${ariaSort}"',  // Support dynamic ariaSort variable
          /aria-sort="\$\{[^}]*\}"/  // Regex for any aria-sort with expression
        ],
        badPatterns: ['aria-sort=""', 'aria-sort="${ariaSort || \'\'}"'],
        description: 'Table sort headers must use aria-sort="none" for unsorted state (not empty string)'
      }
    },
    accordion: {
      // Accordion buttons require explicit aria-expanded values
      ariaExpandedPattern: {
        goodPatterns: [
          'aria-expanded="true"',
          'aria-expanded="false"',
          'aria-expanded="${item.expanded ? \'true\' : \'false\'}"',
          'aria-expanded="${isExpanded ? \'true\' : \'false\'}"',  // Support isExpanded variable
          /aria-expanded="\$\{[^}]+\s*\?\s*['"]true['"]\s*:\s*['"]false['"]\s*\}"/  // Regex for any ternary pattern
        ],
        badPatterns: ['aria-expanded=""', 'aria-expanded="${expanded || \'\'}"'],
        description: 'Accordion buttons must have explicit aria-expanded values (not empty string)'
      }
    },
    modal: {
      // Modal must have explicit aria-hidden values
      ariaHiddenPattern: {
        goodPatterns: ['aria-hidden="true"', 'aria-hidden="false"', 'aria-hidden="${this.open ? \'false\' : \'true\'}"'],
        badPatterns: ['aria-hidden=""', 'aria-hidden="${hidden || \'\'}"'],
        description: 'Modal must have explicit aria-hidden values (not empty string)'
      }
    }
  };

  // Check for empty string attribute patterns that break CSS selectors
  const emptyAttributePattern = /(aria-\w+)="\$\{[^}]*\|\|\s*['"']['"']\}"/g;
  const emptyAttributeMatches = content.match(emptyAttributePattern);

  if (emptyAttributeMatches) {
    emptyAttributeMatches.forEach(match => {
      issues.push(`Empty attribute fallback detected: ${match}. This breaks USWDS CSS selectors - use specific values like "none"`);
    });
  } else {
    successes.push('No empty string attribute fallbacks found');
  }

  // Component-specific validations
  if (criticalPatterns[componentName]) {
    const patterns = criticalPatterns[componentName];

    for (const [patternName, pattern] of Object.entries(patterns)) {
      let foundBadPattern = false;
      let foundGoodPattern = false;

      // Check for bad patterns
      pattern.badPatterns.forEach(badPattern => {
        if (content.includes(badPattern)) {
          issues.push(`${pattern.description}: Found "${badPattern}"`);
          foundBadPattern = true;
        }
      });

      // Check for good patterns (support both strings and regex)
      pattern.goodPatterns.forEach(goodPattern => {
        if (goodPattern instanceof RegExp) {
          if (goodPattern.test(content)) {
            foundGoodPattern = true;
          }
        } else if (content.includes(goodPattern)) {
          foundGoodPattern = true;
        }
      });

      // Report success if good patterns found and no bad patterns
      if (foundGoodPattern && !foundBadPattern) {
        successes.push(`${componentName} uses correct ${patternName.replace('Pattern', '')} attribute pattern`);
      } else if (!foundGoodPattern && !foundBadPattern) {
        warnings.push(`${componentName} may be missing ${patternName.replace('Pattern', '')} attributes`);
      }
    }
  } else {
    successes.push(`CSS selector validation not required for ${componentName} component`);
  }

  return { issues, successes, warnings };
}

/**
 * Validate visual and functional implementation issues
 */
function validateVisualFunctional(content, componentName) {
  const issues = [];
  const successes = [];
  const warnings = [];

  // Anti-patterns that cause visual/functional issues
  const antiPatterns = {
    // Table: Pre-creating buttons that USWDS should create
    tablePreCreatedButtons: {
      pattern: /<button[^>]*class="usa-table__header__button"/,
      message: 'Table headers pre-create sort buttons - USWDS JavaScript should create these automatically',
      severity: 'issue'
    },
    // Modal: Hardcoded sprite paths instead of using usa-icon
    modalHardcodedSprite: {
      pattern: /<use href="[^"]*sprite\.svg#/,
      message: 'Modal uses hardcoded sprite SVG path - should use usa-icon component instead',
      severity: 'issue'
    },
    // General: Hardcoded asset paths that may not exist
    hardcodedAssetPaths: {
      pattern: /href="\/assets\/img\//,
      message: 'Hardcoded asset path may not exist in all environments',
      severity: 'warning'
    },
    // Icons: Direct SVG without usa-icon component
    directSvgIcon: {
      pattern: /<svg[^>]*class="usa-icon"[^>]*>\s*<use/,
      message: 'Direct SVG icon usage - consider using usa-icon component for consistency',
      severity: 'warning'
    }
  };

  // Component-specific checks
  if (componentName === 'table') {
    // Check if table properly delegates to USWDS for sort functionality
    if (antiPatterns.tablePreCreatedButtons.pattern.test(content)) {
      issues.push(antiPatterns.tablePreCreatedButtons.message);
    } else {
      successes.push('Table properly delegates sort button creation to USWDS JavaScript');
    }

    // Check for proper USWDS structure
    if (content.includes('data-sortable')) {
      successes.push('Table uses correct USWDS data-sortable attribute');
    } else {
      warnings.push('Table may be missing data-sortable attributes for sortable columns');
    }
  }

  if (componentName === 'modal') {
    // Modal MUST use inline HTML (buttons and SVG) for USWDS compatibility
    // Check for proper USWDS modal structure
    if (content.includes('data-close-modal')) {
      successes.push('Modal uses correct USWDS data-close-modal attribute');
    }

    // Inline SVG is required for modal - not an anti-pattern
    if (content.includes('class="usa-icon"') && content.includes('<svg')) {
      successes.push('Modal properly uses inline SVG for USWDS compatibility');
    }
  }

  // General anti-pattern checks for all components
  for (const [patternName, pattern] of Object.entries(antiPatterns)) {
    // Skip directSvgIcon check for modal - it MUST use inline SVG
    if (componentName === 'modal' && patternName === 'directSvgIcon') {
      continue;
    }

    if (pattern.pattern.test(content)) {
      const message = `${pattern.message} (${patternName})`;
      if (pattern.severity === 'issue') {
        if (!issues.includes(pattern.message)) {
          issues.push(pattern.message);
        }
      } else {
        if (!warnings.includes(pattern.message)) {
          warnings.push(pattern.message);
        }
      }
    }
  }

  // Check for proper icon component imports
  if (content.includes('<usa-icon')) {
    if (content.includes("import '../icon/index.js'") || content.includes("import '../icon'")) {
      successes.push('Component properly imports usa-icon dependency');
    } else {
      warnings.push('Component uses usa-icon but may be missing import');
    }
  }

  // CSS Selector Validation (prevents "gray button" issues)
  const cssSelectorIssues = validateCSSSelectors(content, componentName);
  issues.push(...cssSelectorIssues.issues);
  warnings.push(...cssSelectorIssues.warnings);
  successes.push(...cssSelectorIssues.successes);

  return { issues, successes, warnings };
}

/**
 * Validate that components don't pre-build structures that USWDS generates
 */
function validateDOMTransformation(content, componentName) {
  const issues = [];
  const successes = [];
  const warnings = [];

  // Check if this component has USWDS DOM transformation requirements
  const transformConfig = USWDS_DOM_TRANSFORMATION_COMPONENTS[componentName];

  if (!transformConfig) {
    return { issues, successes, warnings };
  }

  // Check for forbidden pre-built structures
  let hasPreBuiltStructure = false;
  for (const forbiddenSelector of transformConfig.forbiddenPreBuilt) {
    // Check if the render method contains forbidden pre-built structures
    const selectorPattern = forbiddenSelector.replace('.', '').replace(/-/g, '\\-');
    const classPattern = new RegExp(`class=["'].*?${selectorPattern}.*?["']`, 'g');
    const elementPattern = new RegExp(`<${forbiddenSelector.replace('.', '')}`, 'g');

    if (classPattern.test(content) || elementPattern.test(content)) {
      hasPreBuiltStructure = true;
      issues.push(`âŒ DOM Transformation Issue: ${transformConfig.warningMessage}`);
      issues.push(`   Found pre-built structure: ${forbiddenSelector}`);
      issues.push(`   Expected: ${transformConfig.initialStructure}`);
    }
  }

  if (!hasPreBuiltStructure) {
    successes.push(`âœ… Correct DOM structure for USWDS transformation`);
    successes.push(`   ${transformConfig.description}`);
  }

  // Check that the component properly waits for USWDS transformation
  if (content.includes('firstUpdated') && content.includes('initializeUSWDS')) {
    successes.push('âœ… Properly initializes USWDS in firstUpdated lifecycle');
  }

  // Check for proper transformation detection
  if (content.includes('data-uswds-init') || content.includes('data-enhanced')) {
    successes.push('âœ… Includes guards to prevent duplicate USWDS initialization');
  }

  return { issues, successes, warnings };
}

/**
 * Validate a single component
 */
function validateComponent(componentName) {
  const componentPaths = getAllComponentPaths();
  const componentDir = componentPaths.find(p => basename(p) === componentName);

  if (!componentDir) {
    return null;
  }

  const componentFile = join(componentDir, `usa-${componentName}.ts`);

  if (!existsSync(componentFile)) {
    return null;
  }

  const content = readFileSync(componentFile, 'utf-8');

  // Run all validations
  const htmlResults = validateHTMLStructure(content, componentName);
  const jsResults = validateJSIntegration(content, componentName);
  const cssResults = validateCSS(content);
  const visualResults = validateVisualFunctional(content, componentName);
  const domTransformResults = validateDOMTransformation(content, componentName);

  // Combine results
  const issues = [...htmlResults.issues, ...jsResults.issues, ...cssResults.issues, ...visualResults.issues, ...domTransformResults.issues];
  const warnings = [...htmlResults.warnings, ...jsResults.warnings, ...cssResults.warnings, ...visualResults.warnings, ...domTransformResults.warnings];
  const successes = [...htmlResults.successes, ...jsResults.successes, ...cssResults.successes, ...visualResults.successes, ...domTransformResults.successes];

  // Calculate score
  const total = issues.length + warnings.length + successes.length;
  const score = total > 0 ? (successes.length * 100 - issues.length * 50 - warnings.length * 20) / total : 100;

  return {
    name: componentName,
    issues,
    warnings,
    successes,
    score: Math.max(0, Math.min(100, score))
  };
}

/**
 * Main validation function
 */
function validateAllComponents() {
  console.log(colors.bold(colors.blue('\nðŸ” USWDS Light Wrapper Compliance Report\n')));
  console.log(colors.gray('=' .repeat(80)));

  const components = getAllComponentNames().sort();

  const results = [];
  let totalIssues = 0;
  let totalWarnings = 0;

  // Focus on key components first
  const priorityComponents = ['modal', 'accordion', 'combo-box', 'date-picker'];
  const regularComponents = components.filter(c => !priorityComponents.includes(c));

  console.log(colors.bold(colors.magenta('\nðŸŽ¯ Priority Components (Key USWDS Patterns):\n')));

  priorityComponents.forEach(componentName => {
    if (components.includes(componentName)) {
      const result = validateComponent(componentName);
      if (result) {
        results.push(result);
        totalIssues += result.issues.length;
        totalWarnings += result.warnings.length;
        displayComponentResult(result);
      }
    }
  });

  console.log(colors.bold(colors.cyan('\nðŸ“¦ Other Components:\n')));

  regularComponents.forEach(componentName => {
    const result = validateComponent(componentName);
    if (result) {
      results.push(result);
      totalIssues += result.issues.length;
      totalWarnings += result.warnings.length;

      // Only show details for components with issues
      if (result.issues.length > 0 || result.warnings.length > 0) {
        displayComponentResult(result);
      } else {
        console.log(colors.green(`  âœ… ${componentName} (${result.score.toFixed(0)}%)`));
      }
    }
  });

  // Summary
  displaySummary(results, totalIssues, totalWarnings);
}

/**
 * Display individual component result
 */
function displayComponentResult(result) {
  console.log(colors.bold(colors.cyan(`\nðŸ“¦ ${result.name}`)));
  console.log(colors.gray('-'.repeat(40)));

  // Show score first
  const scoreColor = result.score >= 80 ? 'green' : result.score >= 60 ? 'yellow' : 'red';
  console.log(colors[scoreColor](`  Score: ${result.score.toFixed(1)}%`));

  // Show issues
  if (result.issues.length > 0) {
    console.log(colors.red('\n  Critical Issues:'));
    result.issues.forEach(issue => {
      console.log(colors.red(`    âŒ ${issue}`));
    });
  }

  // Show warnings
  if (result.warnings.length > 0) {
    console.log(colors.yellow('\n  Warnings:'));
    result.warnings.forEach(warning => {
      console.log(colors.yellow(`    âš ï¸  ${warning}`));
    });
  }

  // Show successes (collapsed for clean components)
  if (result.successes.length > 0 && result.issues.length === 0) {
    console.log(colors.green(`  âœ… ${result.successes.length} compliance checks passed`));
  }
}

/**
 * Display summary
 */
function displaySummary(results, totalIssues, totalWarnings) {
  console.log(colors.gray('\n' + '=' .repeat(80)));
  console.log(colors.bold(colors.blue('\nðŸ“Š USWDS Compliance Summary\n')));

  const perfectComponents = results.filter(r => r.score === 100);
  const goodComponents = results.filter(r => r.score >= 80 && r.score < 100);
  const needsWork = results.filter(r => r.score < 80);

  console.log(`  Total Components: ${results.length}`);
  console.log(colors.green(`  Perfect (100%): ${perfectComponents.length}`));
  console.log(colors.yellow(`  Good (80-99%): ${goodComponents.length}`));
  console.log(colors.red(`  Needs Work (<80%): ${needsWork.length}`));
  console.log(colors.red(`  Total Issues: ${totalIssues}`));
  console.log(colors.yellow(`  Total Warnings: ${totalWarnings}`));

  if (perfectComponents.length > 0) {
    console.log(colors.green(`\n  Perfect Components: ${perfectComponents.map(c => c.name).join(', ')}`));
  }

  if (needsWork.length > 0) {
    console.log(colors.red(`\n  Need Attention: ${needsWork.map(c => c.name).join(', ')}`));
  }

  const avgScore = results.reduce((sum, r) => sum + r.score, 0) / results.length;
  const avgColor = avgScore >= 80 ? 'green' : avgScore >= 60 ? 'yellow' : 'red';
  console.log(colors.bold(colors[avgColor](`\n  Average Score: ${avgScore.toFixed(1)}%`)));

  // Recommendations
  if (totalIssues > 0) {
    console.log(colors.bold(colors.magenta('\nðŸ’¡ Top Recommendations:')));
    console.log('  1. Fix HTML structure (use modal as reference for proper USWDS structure)');
    console.log('  2. Add USWDS JavaScript integration for interactive components');
    console.log('  3. Remove custom CSS and use USWDS utility classes only');
    console.log('  4. Ensure all components use light DOM for USWDS compatibility');
    console.log('  5. Add required ARIA attributes for accessibility');
  }

  console.log(colors.gray('\n' + '=' .repeat(80)));

  process.exit(totalIssues > 0 ? 1 : 0);
}

// Run validation
validateAllComponents();